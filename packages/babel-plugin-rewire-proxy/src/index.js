import template from '@babel/template';

const ignoreRegEx = /(^|\s?)rewire-ignore(\s|$)/;

export default function ({types: t}) {
  const VISITED = Symbol('visited');

  const defaultIdentifier = t.identifier('default');

  const buildRewireObjects = template(`
    import _rewireProxyRuntime from '@itaylor/rewire-proxy-runtime';
  `);

  const buildRewireVarDecl = template(`
    const { _$rwRuntime, _$rwProx } = _rewireProxyRuntime();
  `);
  
  // Abuses var decl to allow to overwrite a function with its own proxy without actually renaming the function
  // Function.name stability is important for some cases (like React Components)
  const proxyFunctionTemplate = template(`
    var INTERNALNAME = EXTERNALNAME;
    var EXTERNALNAME = _$rwProx(INTERNALNAME, EXTERNALNAMESTR, () => EXTERNALNAME, (val) => EXTERNALNAME = val);
  `);

  const proxyImportTemplate = template(`
    var EXTERNALNAME = _$rwProx(INTERNALNAME, EXTERNALNAMESTR, () => EXTERNALNAME, (val) => EXTERNALNAME = val);
  `);

  const proxyTemplate = template(`
    EXTERNALNAME = _$rwProx(EXTERNALNAME, EXTERNALNAMESTR, () => EXTERNALNAME, (val) => EXTERNALNAME = val);
  `);

  const defaultExportTemplate = template(`
    export default IDENT;
  `);

  function buildProxyImportTemplate(externalName, internalName) {
    return proxyImportTemplate({
      EXTERNALNAME: externalName,
      INTERNALNAME: internalName,
      EXTERNALNAMESTR: t.stringLiteral(externalName.name),
    });
  }
  function buildProxyTemplate(externalName) {
    return proxyTemplate({
      EXTERNALNAME: externalName,
      EXTERNALNAMESTR: t.stringLiteral(externalName.name),
    });
  }

  function markVisited(node) {
    node[VISITED] = true;
    return node;
  }
  function markAllVisited(nodeOrNodes) {
    if (nodeOrNodes.map) {
      return nodeOrNodes.map(markAllVisited);
    }
    return markVisited(nodeOrNodes);
  }

  return {
    name: 'rewire-proxies',
    visitor: {
      Program: {
        enter(path, state) {
          state.exports = [];
          state.hoistedFunctions = [];
          const ignored = !!state?.file?.ast?.comments?.find((c) => ignoreRegEx.test(c.value));
          if (ignored) {
            path.skip();
          }
        },
        exit(path, {exports, hoistedFunctions} ) {
          exports.push({ local: t.identifier('_$rwRuntime'), external: t.identifier('__RewireAPI__') });
          let defaultExport = null;
          let otherExportSpecifiers = [];
          exports.forEach((e) => {
            if (e.external.name === 'default') {
              defaultExport = defaultExportTemplate({ IDENT: e.local });
            } else {
              otherExportSpecifiers.push(t.exportSpecifier(e.local, e.external));
            }
          });
          const exportDecls = [];
          if (defaultExport) {
            exportDecls.push(markAllVisited(defaultExport));
          }
          if (otherExportSpecifiers.length) {
            exportDecls.push(markAllVisited(t.exportNamedDeclaration(null, otherExportSpecifiers)));
          }
          path.pushContainer('body', exportDecls);
          const varDecl = markVisited(buildRewireVarDecl());
          
          const hoisted = [];
          hoistedFunctions.forEach((h) => {
            proxyFunctionTemplate({ 
              EXTERNALNAME: t.identifier(h.origId),
              INTERNALNAME: t.identifier(h.newId),
              EXTERNALNAMESTR: t.stringLiteral(h.origId),
            }).forEach((n) => hoisted.push(markVisited(n)));
          });
          path.unshiftContainer('body', [markVisited(buildRewireObjects({})), varDecl, ...hoisted,]);
        }
      },
      VariableDeclaration(path) {
        if (path.node[VISITED]) return;
        if (path?.scope?.block?.type === 'Program') {
          // only modify top level variables 
          // don't modify "private" funcs prefixed with _ (babel adds some)
          const name = path?.node?.declarations[0]?.id?.name;
          if (name && name.startsWith('_')) return;
          // Already transformed this node, but some other plugin rewrote the vardecl and lost the VISITED prop, don't do it again.
          if (name && name.endsWith('_rewire')) return;
      
          if (path?.node?.declarations?.length === 1 && !path.node.declarations[0].init) {
            //bare var decl with no assignment.  Often generated by typescript for `enum` types.
            //skip for now?  TODO: maybe check to see if it's followed by an iife that assigns to it?
            markVisited(path.node);
            return;
          }
          
          const decls = path.node.declarations;
          const replacements = [];
          for ( const d of decls ) {
            const ids = getIdentifiersFromMaybePattern(d.id);
            for (const id of ids ) {
              replacements.push(markAllVisited(buildProxyTemplate(id)));
            }
          }
          path.node.kind = 'var';
          path.insertAfter(replacements);
        }
      },
      ClassDeclaration(path) {
        if (path.node[VISITED]) return;
        if (path?.parent?.type === 'Program') {
          // convert ClassDecl to ClassExpression
          // path.node.type = 'ClassExpression';
          path.insertAfter(markAllVisited(buildProxyTemplate(path.node.id)));
        }
      },
      FunctionDeclaration(path, { hoistedFunctions }) {
        if (path.node[VISITED]) return;
        if (path?.parent?.type === 'Program') {
          // only modify top level functions

          const origId = path.node.id.name;
          // don't modify "private" funcs prefixed with _ (babel adds some)
          if (origId.startsWith('_')) return;
          const newId = path.scope.generateUidIdentifier(origId);
          hoistedFunctions.push({ origId, newId: newId.name });
        }
      },      
      ImportDeclaration(path) {
        if (path.node[VISITED]) return;
        const specifiers = path.node.specifiers;
        for (const s of specifiers) {
          if (s.type === 'ImportDefaultSpecifier' || s.type === 'ImportSpecifier' || s.type === 'ImportNamespaceSpecifier' ) {
            const externalName = s.local.name;
            if (externalName.endsWith('_rewire')) {
              //don't mess with imports of rewire functions
              return;
            }
            const internalName = `${externalName}_rewire`;
            s.local.name = internalName;
            path.insertAfter(markVisited(buildProxyImportTemplate(t.identifier(externalName), t.identifier(internalName))));
          }
        }
        path.replaceWith(markVisited(t.ImportDeclaration(specifiers, path.node.source)));
      },
      // export default
      ExportDefaultDeclaration(path, {exports}) {
        if (path.node[VISITED]) return;
        
        const declaration = path.node.declaration;
        const isIdentifier = t.isIdentifier(declaration);
        const binding = isIdentifier && path.scope.getBinding(declaration.name);
        if (isIdentifier && binding) {
          // export default foo
          exports.push({ local: declaration, external: defaultIdentifier });
          // move the export to the end
          path.remove();
        } else if(t.isFunctionDeclaration(declaration) || t.isClassDeclaration(declaration)) {
          // export default class {
          // export default function {}
          if (!declaration?.id || declaration.id.name === 'default') {
            declaration.id = path.scope.generateUidIdentifier('default');
          }
          exports.push({ local: declaration.id, external: defaultIdentifier });
          path.replaceWith(declaration);
        } else {
          // export default "somevalue"
          const id = path.scope.generateUidIdentifier('default');
          path.replaceWith(t.variableDeclaration('const', [t.variableDeclarator(id, declaration)]));
          exports.push({ local: id, external: defaultIdentifier});
        }
      },
      // export {}
      ExportNamedDeclaration(path, {exports}) {
        if (path.node[VISITED]) return;
        // export { foo } from './bar.js'
        if (path.node.source) return;

        const declaration = path.node.declaration;
        if (t.isVariableDeclaration(declaration)) {
          // export const foo = bar, biff = baz;
          const newDeclarations = [];
          path.node.declaration.declarations.forEach((d) => {
            newDeclarations.push(t.variableDeclaration(path.node.declaration.kind, [d]));
            const ids = getIdentifiersFromMaybePattern(d.id);
            ids.forEach((id) => exports.push({ local: id, external:id }));
          });
          path.replaceWithMultiple(newDeclarations);
        } else if (t.isFunctionDeclaration(declaration) || t.isClassDeclaration(declaration)) {
          // export class foo {
          // export function foo() {}
          const id = path.node.declaration.id;
          path.replaceWithMultiple([
            declaration,
          ]);
          exports.push({ local: id, external: id });
        } else if (t?.isTSEnumDeclaration()) {
          return; // this will get converted into a VarDecl and processed later?
        } else {
          // export {foo}
          // move the named exports to the end of the file
          if (path?.node?.specifiers?.length) {
            path.node.specifiers.forEach(s => exports.push({
              local: s.local,
              external: s.exported
            }));
            path.remove();
          }
        }
      }
    }
  };
}

function getIdentifiersFromObjectPattern(op) {
  const ids = [];
  for (const prop of op.properties) {
    let targetId;
    if (prop.type === 'ObjectProperty') {
      if (prop?.value?.type === 'Identifier') {
        targetId = prop.value;
      } else if (prop?.value?.type === 'AssignmentPattern' && prop?.value?.left?.type === 'Identifier') {
        targetId = prop.value.left;
      } else if (prop?.value?.type === 'ObjectPattern' || prop?.value?.type === 'ArrayPattern') {
        ids.push(...getIdentifiersFromMaybePattern(prop.value));
      }
    } else if (prop.type === 'RestElement') {
      targetId = prop.argument;
    }
    if (targetId) {
      ids.push(targetId);
    }
  }
  return ids;
}

function getIdentifiersFromMaybePattern(identiferOrPattern) {
  if (identiferOrPattern.type === 'Identifier') {
    return [identiferOrPattern];
  }
  if (identiferOrPattern.type === 'ObjectPattern') {
    return getIdentifiersFromObjectPattern(identiferOrPattern);
  }
  if (identiferOrPattern.type === 'ArrayPattern') {
    return getIdentifiersFromArrayPattern(identiferOrPattern);
  }
  return [];
}

function getIdentifiersFromArrayPattern(ap) {
  const ids = [];
  for (const ele of ap.elements) {
    let targetId;
    if (ele.type === 'Identifier') {
      targetId = ele;
    } else if (ele.type === 'RestElement') {
      targetId = ele.argument;
    } else if (ele.type === 'AssignmentPattern') {
      targetId = ele.left;
    } else if (ele.type === 'ObjectPattern' || ele.type === 'ArrayPattern') {
      ids.push(...getIdentifiersFromMaybePattern(ele));
    }
    if (targetId) {
      ids.push(targetId);
    }
  }
  return ids;
}

